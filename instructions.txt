
##First create a test Cluster... Change the ssh key configuration, and the ip addresses in the file accordingly.
k0sctl apply --config cluser_creation/cluster_config.yaml --no-wait 
cilium install --version 1.16.1 --values cilium_values.yaml 
cilium status --wait

##Then create an admin service account following the steps in admin-sa creation folder.

##Deploy the dummy spring project using:
kubectl create namespace spring-app
kubectl apply -f spring-app/simple_spring_app.yaml -n spring-app
kubectl apply -f spring-app/ingress.yaml

##Applying Metrics API in a cluster... wait a while.. most likely needed for pod metrics
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

##Applying kube-state-metrics for detecting Kube States.. most likely needed for pod phases
kubectl apply -f https://raw.githubusercontent.com/kubernetes/kube-state-metrics/master/examples/standard/deployment.yaml

##Use this to add custom created service account name here... in this case it is admin-sa
kubectl patch deployment kube-state-metrics -n kube-system --type='json' -p='[{"op": "add", "path": "/spec/template/spec/serviceAccountName", "value": "admin-sa"}]'
kubectl patch deployment metrics-server -n kube-system --type='json' -p='[{"op": "add", "path": "/spec/template/spec/serviceAccountName", "value": "admin-sa"}]'

#Helm deploy openebs storageclass
helm upgrade --install openebs openebs/openebs --namespace openebs --create-namespace
kubectl patch storageclass openebs-hostpath -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

##Helm deploy minio
#Minio Operator Installation:
helm upgrade --install \
  --namespace minio-operator \
  --create-namespace \
  operator minio-operator/operator -f operator-values.yaml

    kubectl apply -f operator-console-nodeport-service.yaml
    
#Tenant Installation:
helm upgrade --install \
  --namespace minio-tenant \
  --create-namespace \
  tenant minio-operator/tenant -f tenant-values.yaml

##Minio console ingress   
kubectl apply -f minio/ingress.yaml -n minio-tenant


##Helm deploy prometheus
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm upgrade --install prometheus prometheus-community/prometheus -f prometheus/prometheus-values.yaml --namespace prometheus --create-namespace


##Helm deploy loki
helm upgrade --install loki grafana/loki -f loki/loki-memberlist.yaml --namespace loki --create-namespace

##Helm deploy tempo
helm upgrade --install tempo grafana/tempo-distributed -f tempo/tempo-values.yaml --namespace tempo

##Helm deploy opentelemetry operator
helm upgrade --install -n opentelemetry opentelemetry-operator open-telemetry/opentelemetry-operator -f otel/otel-operator-values.yaml

##Apply opentelemetry-collector in daemonset mode... if needed change to deployment
kubectl apply -n opentelemetry -f otel/otel-collector.yaml

##Helm deploy opentelemetry collector
#helm repo add open-telemetry https://open-telemetry.github.io/opentelemetry-helm-charts
#helm upgrade --install opentelemetry-collector open-telemetry/opentelemetry-collector --set mode=daemonset --set image.repository="otel/opentelemetry-collector-k8s" --set command.name="otelcol-k8s" -n opentelemetry



##Helm deploy grafana
kubectl create secret generic grafana-admin-secret \
  --from-literal=admin-user=admin \
  --from-literal=admin-password=fintech@bs23 \
  --namespace grafana

  

helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
helm upgrade --install grafana grafana/grafana -f grafana/grafana-values.yaml --namespace grafana

##Access Grafana, and Prometheus UI by port forwarding them at 3000, and 9090 respectively.
##Import the dashboards in the dashboards folder in grafana dashboards ui